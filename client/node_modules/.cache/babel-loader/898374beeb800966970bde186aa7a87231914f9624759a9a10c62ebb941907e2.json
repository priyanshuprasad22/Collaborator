{"ast":null,"code":"'use strict';\n\nconst StringScanner = require('./StringScanner');\nconst syntax = require('./syntax');\nconst XmlCdata = require('./XmlCdata');\nconst XmlComment = require('./XmlComment');\nconst XmlDocument = require('./XmlDocument');\nconst XmlElement = require('./XmlElement');\nconst XmlProcessingInstruction = require('./XmlProcessingInstruction');\nconst XmlText = require('./XmlText');\nconst emptyString = '';\n\n/**\nParses an XML string into an `XmlDocument`.\n\n@private\n*/\nclass Parser {\n  /**\n  @param {string} xml\n    XML string to parse.\n   @param {object} [options]\n    Parsing options.\n     @param {boolean} [options.ignoreUndefinedEntities=false]\n    @param {boolean} [options.preserveCdata=false]\n    @param {boolean} [options.preserveComments=false]\n    @param {(entity: string) => string?} [options.resolveUndefinedEntity]\n    @param {boolean} [options.sortAttributes=false]\n  */\n  constructor(xml) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    /** @type {XmlDocument} */\n    this.document = new XmlDocument();\n\n    /** @type {XmlDocument|XmlElement} */\n    this.currentNode = this.document;\n    this.options = options;\n    this.scanner = new StringScanner(normalizeXmlString(xml));\n    this.consumeProlog();\n    if (!this.consumeElement()) {\n      this.error('Root element is missing or invalid');\n    }\n    while (this.consumeMisc()) {} // eslint-disable-line no-empty\n\n    if (!this.scanner.isEnd) {\n      this.error('Extra content at the end of the document');\n    }\n  }\n\n  /**\n  Adds the given `XmlNode` as a child of `this.currentNode`.\n   @param {XmlNode} node\n  */\n  addNode(node) {\n    node.parent = this.currentNode;\n\n    // @ts-ignore\n    this.currentNode.children.push(node);\n  }\n\n  /**\n  Adds the given _text_ to the document, either by appending it to a preceding\n  `XmlText` node (if possible) or by creating a new `XmlText` node.\n   @param {string} text\n  */\n  addText(text) {\n    let {\n      children\n    } = this.currentNode;\n    if (children.length > 0) {\n      let prevNode = children[children.length - 1];\n      if (prevNode instanceof XmlText) {\n        // The previous node is a text node, so we can append to it and avoid\n        // creating another node.\n        prevNode.text += text;\n        return;\n      }\n    }\n    this.addNode(new XmlText(text));\n  }\n\n  /**\n  Consumes an `AttValue` (attribute value) if possible.\n   @returns {string|false}\n    Contents of the `AttValue` minus quotes, or `false` if nothing was consumed.\n    An empty string indicates that an `AttValue` was consumed but was empty.\n   @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-AttValue\n  */\n  consumeAttributeValue() {\n    let {\n      scanner\n    } = this;\n    let quote = scanner.peek();\n    if (quote !== '\"' && quote !== \"'\") {\n      return false;\n    }\n    scanner.advance();\n    let chars;\n    let isClosed = false;\n    let value = emptyString;\n    let regex = quote === '\"' ? /[^\"&<]+/y : /[^'&<]+/y;\n    matchLoop: while (!scanner.isEnd) {\n      chars = scanner.consumeMatch(regex);\n      if (chars) {\n        this.validateChars(chars);\n        value += chars.replace(/[\\t\\r\\n]/g, ' ');\n      }\n      let nextChar = scanner.peek();\n      switch (nextChar) {\n        case quote:\n          isClosed = true;\n          break matchLoop;\n        case '&':\n          value += this.consumeReference();\n          continue;\n        case '<':\n          this.error('Unescaped `<` is not allowed in an attribute value'); /* istanbul ignore next */\n          break;\n        case emptyString:\n          this.error('Unclosed attribute'); /* istanbul ignore next */\n          break;\n      }\n    }\n    if (!isClosed) {\n      this.error('Unclosed attribute');\n    }\n    scanner.advance();\n    return value;\n  }\n\n  /**\n  Consumes a CDATA section if possible.\n   @returns {boolean}\n    Whether a CDATA section was consumed.\n   @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-cdata-sect\n  */\n  consumeCdataSection() {\n    let {\n      scanner\n    } = this;\n    if (!scanner.consumeStringFast('<![CDATA[')) {\n      return false;\n    }\n    let text = scanner.consumeUntilString(']]>');\n    this.validateChars(text);\n    if (!scanner.consumeStringFast(']]>')) {\n      this.error('Unclosed CDATA section');\n    }\n    if (this.options.preserveCdata) {\n      this.addNode(new XmlCdata(text));\n    } else {\n      this.addText(text);\n    }\n    return true;\n  }\n\n  /**\n  Consumes character data if possible.\n   @returns {boolean}\n    Whether character data was consumed.\n   @see https://www.w3.org/TR/2008/REC-xml-20081126/#dt-chardata\n  */\n  consumeCharData() {\n    let {\n      scanner\n    } = this;\n    let charData = scanner.consumeUntilMatch(/<|&|]]>/g);\n    if (!charData) {\n      return false;\n    }\n    this.validateChars(charData);\n    if (scanner.peek() === ']' && scanner.peek(3) === ']]>') {\n      this.error('Element content may not contain the CDATA section close delimiter `]]>`');\n    }\n    this.addText(charData);\n    return true;\n  }\n\n  /**\n  Consumes a comment if possible.\n   @returns {boolean}\n    Whether a comment was consumed.\n   @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Comment\n  */\n  consumeComment() {\n    let {\n      scanner\n    } = this;\n    if (!scanner.consumeStringFast('<!--')) {\n      return false;\n    }\n    let content = scanner.consumeUntilString('--');\n    this.validateChars(content);\n    if (!scanner.consumeStringFast('-->')) {\n      if (scanner.peek(2) === '--') {\n        this.error(\"The string `--` isn't allowed inside a comment\");\n      } else {\n        this.error('Unclosed comment');\n      }\n    }\n    if (this.options.preserveComments) {\n      this.addNode(new XmlComment(content.trim()));\n    }\n    return true;\n  }\n\n  /**\n  Consumes a reference in a content context if possible.\n   This differs from `consumeReference()` in that a consumed reference will be\n  added to the document as a text node instead of returned.\n   @returns {boolean}\n    Whether a reference was consumed.\n   @see https://www.w3.org/TR/2008/REC-xml-20081126/#entproc\n  */\n  consumeContentReference() {\n    let ref = this.consumeReference();\n    if (ref) {\n      this.addText(ref);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n  Consumes a doctype declaration if possible.\n   This is a loose implementation since doctype declarations are currently\n  discarded without further parsing.\n   @returns {boolean}\n    Whether a doctype declaration was consumed.\n   @see https://www.w3.org/TR/2008/REC-xml-20081126/#dtd\n  */\n  consumeDoctypeDeclaration() {\n    let {\n      scanner\n    } = this;\n    if (!scanner.consumeStringFast('<!DOCTYPE') || !this.consumeWhitespace()) {\n      return false;\n    }\n    scanner.consumeMatch(/[^[>]+/y);\n    if (scanner.consumeMatch(/\\[[\\s\\S]+?\\][\\x20\\t\\r\\n]*>/y)) {\n      return true;\n    }\n    if (!scanner.consumeStringFast('>')) {\n      this.error('Unclosed doctype declaration');\n    }\n    return true;\n  }\n\n  /**\n  Consumes an element if possible.\n   @returns {boolean}\n    Whether an element was consumed.\n   @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-element\n  */\n  consumeElement() {\n    let {\n      scanner\n    } = this;\n    let mark = scanner.charIndex;\n    if (scanner.peek() !== '<') {\n      return false;\n    }\n    scanner.advance();\n    let name = this.consumeName();\n    if (!name) {\n      scanner.reset(mark);\n      return false;\n    }\n    let attributes = Object.create(null);\n    while (this.consumeWhitespace()) {\n      let attrName = this.consumeName();\n      if (!attrName) {\n        continue;\n      }\n      let attrValue = this.consumeEqual() && this.consumeAttributeValue();\n      if (attrValue === false) {\n        this.error('Attribute value expected');\n      }\n      if (attrName in attributes) {\n        this.error(`Duplicate attribute: ${attrName}`);\n      }\n      if (attrName === 'xml:space' && attrValue !== 'default' && attrValue !== 'preserve') {\n        this.error('Value of the `xml:space` attribute must be \"default\" or \"preserve\"');\n      }\n      attributes[attrName] = attrValue;\n    }\n    if (this.options.sortAttributes) {\n      let attrNames = Object.keys(attributes).sort();\n      let sortedAttributes = Object.create(null);\n      for (let i = 0; i < attrNames.length; ++i) {\n        let attrName = attrNames[i];\n        sortedAttributes[attrName] = attributes[attrName];\n      }\n      attributes = sortedAttributes;\n    }\n    let isEmpty = Boolean(scanner.consumeStringFast('/>'));\n    let element = new XmlElement(name, attributes);\n    element.parent = this.currentNode;\n    if (!isEmpty) {\n      if (!scanner.consumeStringFast('>')) {\n        this.error(`Unclosed start tag for element \\`${name}\\``);\n      }\n      this.currentNode = element;\n      this.consumeCharData();\n      while (this.consumeElement() || this.consumeContentReference() || this.consumeCdataSection() || this.consumeProcessingInstruction() || this.consumeComment()) {\n        this.consumeCharData();\n      }\n      let endTagMark = scanner.charIndex;\n      let endTagName;\n      if (!scanner.consumeStringFast('</') || !(endTagName = this.consumeName()) || endTagName !== name) {\n        scanner.reset(endTagMark);\n        this.error(`Missing end tag for element ${name}`);\n      }\n      this.consumeWhitespace();\n      if (!scanner.consumeStringFast('>')) {\n        this.error(`Unclosed end tag for element ${name}`);\n      }\n      this.currentNode = element.parent;\n    }\n    this.addNode(element);\n    return true;\n  }\n\n  /**\n  Consumes an `Eq` production if possible.\n   @returns {boolean}\n    Whether an `Eq` production was consumed.\n   @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Eq\n  */\n  consumeEqual() {\n    this.consumeWhitespace();\n    if (this.scanner.consumeStringFast('=')) {\n      this.consumeWhitespace();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n  Consumes `Misc` content if possible.\n   @returns {boolean}\n    Whether anything was consumed.\n   @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Misc\n  */\n  consumeMisc() {\n    return this.consumeComment() || this.consumeProcessingInstruction() || this.consumeWhitespace();\n  }\n\n  /**\n  Consumes one or more `Name` characters if possible.\n   @returns {string}\n    `Name` characters, or an empty string if none were consumed.\n   @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Name\n  */\n  consumeName() {\n    return syntax.isNameStartChar(this.scanner.peek()) ? this.scanner.consumeMatchFn(syntax.isNameChar) : emptyString;\n  }\n\n  /**\n  Consumes a processing instruction if possible.\n   @returns {boolean}\n    Whether a processing instruction was consumed.\n   @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-pi\n  */\n  consumeProcessingInstruction() {\n    let {\n      scanner\n    } = this;\n    let mark = scanner.charIndex;\n    if (!scanner.consumeStringFast('<?')) {\n      return false;\n    }\n    let name = this.consumeName();\n    if (name) {\n      if (name.toLowerCase() === 'xml') {\n        scanner.reset(mark);\n        this.error(\"XML declaration isn't allowed here\");\n      }\n    } else {\n      this.error('Invalid processing instruction');\n    }\n    if (!this.consumeWhitespace()) {\n      if (scanner.consumeStringFast('?>')) {\n        this.addNode(new XmlProcessingInstruction(name));\n        return true;\n      }\n      this.error('Whitespace is required after a processing instruction name');\n    }\n    let content = scanner.consumeUntilString('?>');\n    this.validateChars(content);\n    if (!scanner.consumeStringFast('?>')) {\n      this.error('Unterminated processing instruction');\n    }\n    this.addNode(new XmlProcessingInstruction(name, content));\n    return true;\n  }\n\n  /**\n  Consumes a prolog if possible.\n   @returns {boolean}\n    Whether a prolog was consumed.\n   @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-prolog-dtd\n  */\n  consumeProlog() {\n    let {\n      scanner\n    } = this;\n    let mark = scanner.charIndex;\n    this.consumeXmlDeclaration();\n    while (this.consumeMisc()) {} // eslint-disable-line no-empty\n\n    if (this.consumeDoctypeDeclaration()) {\n      while (this.consumeMisc()) {} // eslint-disable-line no-empty\n    }\n\n    return mark < scanner.charIndex;\n  }\n\n  /**\n  Consumes a reference if possible.\n   This differs from `consumeContentReference()` in that a consumed reference\n  will be returned rather than added to the document.\n   @returns {string|false}\n    Parsed reference value, or `false` if nothing was consumed (to distinguish\n    from a reference that resolves to an empty string).\n   @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Reference\n  */\n  consumeReference() {\n    let {\n      scanner\n    } = this;\n    if (scanner.peek() !== '&') {\n      return false;\n    }\n    scanner.advance();\n    let ref = scanner.consumeMatchFn(syntax.isReferenceChar);\n    if (scanner.consume() !== ';') {\n      this.error('Unterminated reference (a reference must end with `;`)');\n    }\n    let parsedValue;\n    if (ref[0] === '#') {\n      // This is a character reference.\n      let codePoint = ref[1] === 'x' ? parseInt(ref.slice(2), 16) // Hex codepoint.\n      : parseInt(ref.slice(1), 10); // Decimal codepoint.\n\n      if (isNaN(codePoint)) {\n        this.error('Invalid character reference');\n      }\n      parsedValue = String.fromCodePoint(codePoint);\n      if (!syntax.isXmlChar(parsedValue)) {\n        this.error('Character reference resolves to an invalid character');\n      }\n    } else {\n      // This is an entity reference.\n      parsedValue = syntax.predefinedEntities[ref];\n      if (parsedValue === undefined) {\n        let {\n          ignoreUndefinedEntities,\n          resolveUndefinedEntity\n        } = this.options;\n        let wrappedRef = `&${ref};`; // for backcompat with <= 2.x\n\n        if (resolveUndefinedEntity) {\n          let resolvedValue = resolveUndefinedEntity(wrappedRef);\n          if (resolvedValue !== null && resolvedValue !== undefined) {\n            let type = typeof resolvedValue;\n            if (type !== 'string') {\n              throw new TypeError(`\\`resolveUndefinedEntity()\\` must return a string, \\`null\\`, or \\`undefined\\`, but returned a value of type ${type}`);\n            }\n            return resolvedValue;\n          }\n        }\n        if (ignoreUndefinedEntities) {\n          return wrappedRef;\n        }\n        scanner.reset(-wrappedRef.length);\n        this.error(`Named entity isn't defined: ${wrappedRef}`);\n      }\n    }\n    return parsedValue;\n  }\n\n  /**\n  Consumes a `SystemLiteral` if possible.\n   A `SystemLiteral` is similar to an attribute value, but allows the characters\n  `<` and `&` and doesn't replace references.\n   @returns {string|false}\n    Value of the `SystemLiteral` minus quotes, or `false` if nothing was\n    consumed. An empty string indicates that a `SystemLiteral` was consumed but\n    was empty.\n   @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-SystemLiteral\n  */\n  consumeSystemLiteral() {\n    let {\n      scanner\n    } = this;\n    let quote = scanner.consumeStringFast('\"') || scanner.consumeStringFast(\"'\");\n    if (!quote) {\n      return false;\n    }\n    let value = scanner.consumeUntilString(quote);\n    this.validateChars(value);\n    if (!scanner.consumeStringFast(quote)) {\n      this.error('Missing end quote');\n    }\n    return value;\n  }\n\n  /**\n  Consumes one or more whitespace characters if possible.\n   @returns {boolean}\n    Whether any whitespace characters were consumed.\n   @see https://www.w3.org/TR/2008/REC-xml-20081126/#white\n  */\n  consumeWhitespace() {\n    return Boolean(this.scanner.consumeMatchFn(syntax.isWhitespace));\n  }\n\n  /**\n  Consumes an XML declaration if possible.\n   @returns {boolean}\n    Whether an XML declaration was consumed.\n   @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-XMLDecl\n  */\n  consumeXmlDeclaration() {\n    let {\n      scanner\n    } = this;\n    if (!scanner.consumeStringFast('<?xml')) {\n      return false;\n    }\n    if (!this.consumeWhitespace()) {\n      this.error('Invalid XML declaration');\n    }\n    let version = Boolean(scanner.consumeStringFast('version')) && this.consumeEqual() && this.consumeSystemLiteral();\n    if (version === false) {\n      this.error('XML version is missing or invalid');\n    } else if (!/^1\\.[0-9]+$/.test(version)) {\n      this.error('Invalid character in version number');\n    }\n    if (this.consumeWhitespace()) {\n      let encoding = Boolean(scanner.consumeStringFast('encoding')) && this.consumeEqual() && this.consumeSystemLiteral();\n      if (encoding) {\n        this.consumeWhitespace();\n      }\n      let standalone = Boolean(scanner.consumeStringFast('standalone')) && this.consumeEqual() && this.consumeSystemLiteral();\n      if (standalone) {\n        if (standalone !== 'yes' && standalone !== 'no') {\n          this.error('Only \"yes\" and \"no\" are permitted as values of `standalone`');\n        }\n        this.consumeWhitespace();\n      }\n    }\n    if (!scanner.consumeStringFast('?>')) {\n      this.error('Invalid or unclosed XML declaration');\n    }\n    return true;\n  }\n\n  /**\n  Throws an error at the current scanner position.\n   @param {string} message\n  */\n  error(message) {\n    let {\n      charIndex,\n      string: xml\n    } = this.scanner;\n    let column = 1;\n    let excerpt = '';\n    let line = 1;\n\n    // Find the line and column where the error occurred.\n    for (let i = 0; i < charIndex; ++i) {\n      let char = xml[i];\n      if (char === '\\n') {\n        column = 1;\n        excerpt = '';\n        line += 1;\n      } else {\n        column += 1;\n        excerpt += char;\n      }\n    }\n    let eol = xml.indexOf('\\n', charIndex);\n    excerpt += eol === -1 ? xml.slice(charIndex) : xml.slice(charIndex, eol);\n    let excerptStart = 0;\n\n    // Keep the excerpt below 50 chars, but always keep the error position in\n    // view.\n    if (excerpt.length > 50) {\n      if (column < 40) {\n        excerpt = excerpt.slice(0, 50);\n      } else {\n        excerptStart = column - 20;\n        excerpt = excerpt.slice(excerptStart, column + 30);\n      }\n    }\n    let err = new Error(`${message} (line ${line}, column ${column})\\n` + `  ${excerpt}\\n` + ' '.repeat(column - excerptStart + 1) + '^\\n');\n    Object.assign(err, {\n      column,\n      excerpt,\n      line,\n      pos: charIndex\n    });\n    throw err;\n  }\n\n  /**\n  Throws an invalid character error if any character in the given _string_ isn't\n  a valid XML character.\n   @param {string} string\n  */\n  validateChars(string) {\n    let charIndex = 0;\n    for (let char of string) {\n      if (syntax.isNotXmlChar(char)) {\n        this.scanner.reset(-([...string].length - charIndex));\n        this.error('Invalid character');\n      }\n      charIndex += 1;\n    }\n  }\n}\nmodule.exports = Parser;\n\n// -- Private Functions --------------------------------------------------------\n\n/**\nNormalizes the given XML string by stripping a byte order mark (if present) and\nreplacing CRLF sequences and lone CR characters with LF characters.\n\n@param {string} xml\n@returns {string}\n*/\nfunction normalizeXmlString(xml) {\n  if (xml[0] === '\\uFEFF') {\n    xml = xml.slice(1);\n  }\n  return xml.replace(/\\r\\n?/g, '\\n');\n}\n\n/** @typedef {import('./XmlNode')} XmlNode */","map":{"version":3,"names":["StringScanner","require","syntax","XmlCdata","XmlComment","XmlDocument","XmlElement","XmlProcessingInstruction","XmlText","emptyString","Parser","constructor","xml","options","arguments","length","undefined","document","currentNode","scanner","normalizeXmlString","consumeProlog","consumeElement","error","consumeMisc","isEnd","addNode","node","parent","children","push","addText","text","prevNode","consumeAttributeValue","quote","peek","advance","chars","isClosed","value","regex","matchLoop","consumeMatch","validateChars","replace","nextChar","consumeReference","consumeCdataSection","consumeStringFast","consumeUntilString","preserveCdata","consumeCharData","charData","consumeUntilMatch","consumeComment","content","preserveComments","trim","consumeContentReference","ref","consumeDoctypeDeclaration","consumeWhitespace","mark","charIndex","name","consumeName","reset","attributes","Object","create","attrName","attrValue","consumeEqual","sortAttributes","attrNames","keys","sort","sortedAttributes","i","isEmpty","Boolean","element","consumeProcessingInstruction","endTagMark","endTagName","isNameStartChar","consumeMatchFn","isNameChar","toLowerCase","consumeXmlDeclaration","isReferenceChar","consume","parsedValue","codePoint","parseInt","slice","isNaN","String","fromCodePoint","isXmlChar","predefinedEntities","ignoreUndefinedEntities","resolveUndefinedEntity","wrappedRef","resolvedValue","type","TypeError","consumeSystemLiteral","isWhitespace","version","test","encoding","standalone","message","string","column","excerpt","line","char","eol","indexOf","excerptStart","err","Error","repeat","assign","pos","isNotXmlChar","module","exports"],"sources":["C:/Project-1/Collborator/client/node_modules/@rgrove/parse-xml/src/lib/Parser.js"],"sourcesContent":["'use strict';\n\nconst StringScanner = require('./StringScanner');\nconst syntax = require('./syntax');\nconst XmlCdata = require('./XmlCdata');\nconst XmlComment = require('./XmlComment');\nconst XmlDocument = require('./XmlDocument');\nconst XmlElement = require('./XmlElement');\nconst XmlProcessingInstruction = require('./XmlProcessingInstruction');\nconst XmlText = require('./XmlText');\n\nconst emptyString = '';\n\n/**\nParses an XML string into an `XmlDocument`.\n\n@private\n*/\nclass Parser {\n  /**\n  @param {string} xml\n    XML string to parse.\n\n  @param {object} [options]\n    Parsing options.\n\n    @param {boolean} [options.ignoreUndefinedEntities=false]\n    @param {boolean} [options.preserveCdata=false]\n    @param {boolean} [options.preserveComments=false]\n    @param {(entity: string) => string?} [options.resolveUndefinedEntity]\n    @param {boolean} [options.sortAttributes=false]\n  */\n  constructor(xml, options = {}) {\n    /** @type {XmlDocument} */\n    this.document = new XmlDocument();\n\n    /** @type {XmlDocument|XmlElement} */\n    this.currentNode = this.document;\n\n    this.options = options;\n    this.scanner = new StringScanner(normalizeXmlString(xml));\n\n    this.consumeProlog();\n\n    if (!this.consumeElement()) {\n      this.error('Root element is missing or invalid');\n    }\n\n    while (this.consumeMisc()) {} // eslint-disable-line no-empty\n\n    if (!this.scanner.isEnd) {\n      this.error('Extra content at the end of the document');\n    }\n  }\n\n  /**\n  Adds the given `XmlNode` as a child of `this.currentNode`.\n\n  @param {XmlNode} node\n  */\n  addNode(node) {\n    node.parent = this.currentNode;\n\n    // @ts-ignore\n    this.currentNode.children.push(node);\n  }\n\n  /**\n  Adds the given _text_ to the document, either by appending it to a preceding\n  `XmlText` node (if possible) or by creating a new `XmlText` node.\n\n  @param {string} text\n  */\n  addText(text) {\n    let { children } = this.currentNode;\n\n    if (children.length > 0) {\n      let prevNode = children[children.length - 1];\n\n      if (prevNode instanceof XmlText) {\n        // The previous node is a text node, so we can append to it and avoid\n        // creating another node.\n        prevNode.text += text;\n        return;\n      }\n    }\n\n    this.addNode(new XmlText(text));\n  }\n\n  /**\n  Consumes an `AttValue` (attribute value) if possible.\n\n  @returns {string|false}\n    Contents of the `AttValue` minus quotes, or `false` if nothing was consumed.\n    An empty string indicates that an `AttValue` was consumed but was empty.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-AttValue\n  */\n  consumeAttributeValue() {\n    let { scanner } = this;\n    let quote = scanner.peek();\n\n    if (quote !== '\"' && quote !== \"'\") {\n      return false;\n    }\n\n    scanner.advance();\n\n    let chars;\n    let isClosed = false;\n    let value = emptyString;\n    let regex = quote === '\"'\n      ? /[^\"&<]+/y\n      : /[^'&<]+/y;\n\n    matchLoop: while (!scanner.isEnd) {\n      chars = scanner.consumeMatch(regex);\n\n      if (chars) {\n        this.validateChars(chars);\n        value += chars.replace(/[\\t\\r\\n]/g, ' ');\n      }\n\n      let nextChar = scanner.peek();\n\n      switch (nextChar) {\n        case quote:\n          isClosed = true;\n          break matchLoop;\n\n        case '&':\n          value += this.consumeReference();\n          continue;\n\n        case '<':\n          this.error('Unescaped `<` is not allowed in an attribute value'); /* istanbul ignore next */\n          break;\n\n        case emptyString:\n          this.error('Unclosed attribute'); /* istanbul ignore next */\n          break;\n\n      }\n    }\n\n    if (!isClosed) {\n      this.error('Unclosed attribute');\n    }\n\n    scanner.advance();\n    return value;\n  }\n\n  /**\n  Consumes a CDATA section if possible.\n\n  @returns {boolean}\n    Whether a CDATA section was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-cdata-sect\n  */\n  consumeCdataSection() {\n    let { scanner } = this;\n\n    if (!scanner.consumeStringFast('<![CDATA[')) {\n      return false;\n    }\n\n    let text = scanner.consumeUntilString(']]>');\n    this.validateChars(text);\n\n    if (!scanner.consumeStringFast(']]>')) {\n      this.error('Unclosed CDATA section');\n    }\n\n    if (this.options.preserveCdata) {\n      this.addNode(new XmlCdata(text));\n    } else {\n      this.addText(text);\n    }\n\n    return true;\n  }\n\n  /**\n  Consumes character data if possible.\n\n  @returns {boolean}\n    Whether character data was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#dt-chardata\n  */\n  consumeCharData() {\n    let { scanner } = this;\n    let charData = scanner.consumeUntilMatch(/<|&|]]>/g);\n\n    if (!charData) {\n      return false;\n    }\n\n    this.validateChars(charData);\n\n    if (scanner.peek() === ']' && scanner.peek(3) === ']]>') {\n      this.error('Element content may not contain the CDATA section close delimiter `]]>`');\n    }\n\n    this.addText(charData);\n    return true;\n  }\n\n  /**\n  Consumes a comment if possible.\n\n  @returns {boolean}\n    Whether a comment was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Comment\n  */\n  consumeComment() {\n    let { scanner } = this;\n\n    if (!scanner.consumeStringFast('<!--')) {\n      return false;\n    }\n\n    let content = scanner.consumeUntilString('--');\n    this.validateChars(content);\n\n    if (!scanner.consumeStringFast('-->')) {\n      if (scanner.peek(2) === '--') {\n        this.error(\"The string `--` isn't allowed inside a comment\");\n      } else {\n        this.error('Unclosed comment');\n      }\n    }\n\n    if (this.options.preserveComments) {\n      this.addNode(new XmlComment(content.trim()));\n    }\n\n    return true;\n  }\n\n  /**\n  Consumes a reference in a content context if possible.\n\n  This differs from `consumeReference()` in that a consumed reference will be\n  added to the document as a text node instead of returned.\n\n  @returns {boolean}\n    Whether a reference was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#entproc\n  */\n  consumeContentReference() {\n    let ref = this.consumeReference();\n\n    if (ref) {\n      this.addText(ref);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n  Consumes a doctype declaration if possible.\n\n  This is a loose implementation since doctype declarations are currently\n  discarded without further parsing.\n\n  @returns {boolean}\n    Whether a doctype declaration was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#dtd\n  */\n  consumeDoctypeDeclaration() {\n    let { scanner } = this;\n\n    if (!scanner.consumeStringFast('<!DOCTYPE')\n        || !this.consumeWhitespace()) {\n\n      return false;\n    }\n\n    scanner.consumeMatch(/[^[>]+/y);\n\n    if (scanner.consumeMatch(/\\[[\\s\\S]+?\\][\\x20\\t\\r\\n]*>/y)) {\n      return true;\n    }\n\n    if (!scanner.consumeStringFast('>')) {\n      this.error('Unclosed doctype declaration');\n    }\n\n    return true;\n  }\n\n  /**\n  Consumes an element if possible.\n\n  @returns {boolean}\n    Whether an element was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-element\n  */\n  consumeElement() {\n    let { scanner } = this;\n    let mark = scanner.charIndex;\n\n    if (scanner.peek() !== '<') {\n      return false;\n    }\n\n    scanner.advance();\n    let name = this.consumeName();\n\n    if (!name) {\n      scanner.reset(mark);\n      return false;\n    }\n\n    let attributes = Object.create(null);\n\n    while (this.consumeWhitespace()) {\n      let attrName = this.consumeName();\n\n      if (!attrName) {\n        continue;\n      }\n\n      let attrValue = this.consumeEqual()\n        && this.consumeAttributeValue();\n\n      if (attrValue === false) {\n        this.error('Attribute value expected');\n      }\n\n      if (attrName in attributes) {\n        this.error(`Duplicate attribute: ${attrName}`);\n      }\n\n      if (attrName === 'xml:space'\n          && attrValue !== 'default'\n          && attrValue !== 'preserve') {\n\n        this.error('Value of the `xml:space` attribute must be \"default\" or \"preserve\"');\n      }\n\n      attributes[attrName] = attrValue;\n    }\n\n    if (this.options.sortAttributes) {\n      let attrNames = Object.keys(attributes).sort();\n      let sortedAttributes = Object.create(null);\n\n      for (let i = 0; i < attrNames.length; ++i) {\n        let attrName = attrNames[i];\n        sortedAttributes[attrName] = attributes[attrName];\n      }\n\n      attributes = sortedAttributes;\n    }\n\n    let isEmpty = Boolean(scanner.consumeStringFast('/>'));\n    let element = new XmlElement(name, attributes);\n\n    element.parent = this.currentNode;\n\n    if (!isEmpty) {\n      if (!scanner.consumeStringFast('>')) {\n        this.error(`Unclosed start tag for element \\`${name}\\``);\n      }\n\n      this.currentNode = element;\n      this.consumeCharData();\n\n      while (\n        this.consumeElement()\n          || this.consumeContentReference()\n          || this.consumeCdataSection()\n          || this.consumeProcessingInstruction()\n          || this.consumeComment()\n      ) {\n        this.consumeCharData();\n      }\n\n      let endTagMark = scanner.charIndex;\n      let endTagName;\n\n      if (!scanner.consumeStringFast('</')\n          || !(endTagName = this.consumeName())\n          || endTagName !== name) {\n\n        scanner.reset(endTagMark);\n        this.error(`Missing end tag for element ${name}`);\n      }\n\n      this.consumeWhitespace();\n\n      if (!scanner.consumeStringFast('>')) {\n        this.error(`Unclosed end tag for element ${name}`);\n      }\n\n      this.currentNode = element.parent;\n    }\n\n    this.addNode(element);\n    return true;\n  }\n\n  /**\n  Consumes an `Eq` production if possible.\n\n  @returns {boolean}\n    Whether an `Eq` production was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Eq\n  */\n  consumeEqual() {\n    this.consumeWhitespace();\n\n    if (this.scanner.consumeStringFast('=')) {\n      this.consumeWhitespace();\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n  Consumes `Misc` content if possible.\n\n  @returns {boolean}\n    Whether anything was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Misc\n  */\n  consumeMisc() {\n    return this.consumeComment()\n      || this.consumeProcessingInstruction()\n      || this.consumeWhitespace();\n  }\n\n  /**\n  Consumes one or more `Name` characters if possible.\n\n  @returns {string}\n    `Name` characters, or an empty string if none were consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Name\n  */\n  consumeName() {\n    return syntax.isNameStartChar(this.scanner.peek())\n      ? this.scanner.consumeMatchFn(syntax.isNameChar)\n      : emptyString;\n  }\n\n  /**\n  Consumes a processing instruction if possible.\n\n  @returns {boolean}\n    Whether a processing instruction was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-pi\n  */\n  consumeProcessingInstruction() {\n    let { scanner } = this;\n    let mark = scanner.charIndex;\n\n    if (!scanner.consumeStringFast('<?')) {\n      return false;\n    }\n\n    let name = this.consumeName();\n\n    if (name) {\n      if (name.toLowerCase() === 'xml') {\n        scanner.reset(mark);\n        this.error(\"XML declaration isn't allowed here\");\n      }\n    } else {\n      this.error('Invalid processing instruction');\n    }\n\n    if (!this.consumeWhitespace()) {\n      if (scanner.consumeStringFast('?>')) {\n        this.addNode(new XmlProcessingInstruction(name));\n        return true;\n      }\n\n      this.error('Whitespace is required after a processing instruction name');\n    }\n\n    let content = scanner.consumeUntilString('?>');\n    this.validateChars(content);\n\n    if (!scanner.consumeStringFast('?>')) {\n      this.error('Unterminated processing instruction');\n    }\n\n    this.addNode(new XmlProcessingInstruction(name, content));\n    return true;\n  }\n\n  /**\n  Consumes a prolog if possible.\n\n  @returns {boolean}\n    Whether a prolog was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-prolog-dtd\n  */\n  consumeProlog() {\n    let { scanner } = this;\n    let mark = scanner.charIndex;\n\n    this.consumeXmlDeclaration();\n\n    while (this.consumeMisc()) {} // eslint-disable-line no-empty\n\n    if (this.consumeDoctypeDeclaration()) {\n      while (this.consumeMisc()) {} // eslint-disable-line no-empty\n    }\n\n    return mark < scanner.charIndex;\n  }\n\n  /**\n  Consumes a reference if possible.\n\n  This differs from `consumeContentReference()` in that a consumed reference\n  will be returned rather than added to the document.\n\n  @returns {string|false}\n    Parsed reference value, or `false` if nothing was consumed (to distinguish\n    from a reference that resolves to an empty string).\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-Reference\n  */\n  consumeReference() {\n    let { scanner } = this;\n\n    if (scanner.peek() !== '&') {\n      return false;\n    }\n\n    scanner.advance();\n\n    let ref = scanner.consumeMatchFn(syntax.isReferenceChar);\n\n    if (scanner.consume() !== ';') {\n      this.error('Unterminated reference (a reference must end with `;`)');\n    }\n\n    let parsedValue;\n\n    if (ref[0] === '#') {\n      // This is a character reference.\n      let codePoint = ref[1] === 'x'\n        ? parseInt(ref.slice(2), 16) // Hex codepoint.\n        : parseInt(ref.slice(1), 10); // Decimal codepoint.\n\n      if (isNaN(codePoint)) {\n        this.error('Invalid character reference');\n      }\n\n      parsedValue = String.fromCodePoint(codePoint);\n\n      if (!syntax.isXmlChar(parsedValue)) {\n        this.error('Character reference resolves to an invalid character');\n      }\n    } else {\n      // This is an entity reference.\n      parsedValue = syntax.predefinedEntities[ref];\n\n      if (parsedValue === undefined) {\n        let {\n          ignoreUndefinedEntities,\n          resolveUndefinedEntity\n        } = this.options;\n\n        let wrappedRef = `&${ref};`; // for backcompat with <= 2.x\n\n        if (resolveUndefinedEntity) {\n          let resolvedValue = resolveUndefinedEntity(wrappedRef);\n\n          if (resolvedValue !== null && resolvedValue !== undefined) {\n            let type = typeof resolvedValue;\n\n            if (type !== 'string') {\n              throw new TypeError(`\\`resolveUndefinedEntity()\\` must return a string, \\`null\\`, or \\`undefined\\`, but returned a value of type ${type}`);\n            }\n\n            return resolvedValue;\n          }\n        }\n\n        if (ignoreUndefinedEntities) {\n          return wrappedRef;\n        }\n\n        scanner.reset(-wrappedRef.length);\n        this.error(`Named entity isn't defined: ${wrappedRef}`);\n      }\n    }\n\n    return parsedValue;\n  }\n\n  /**\n  Consumes a `SystemLiteral` if possible.\n\n  A `SystemLiteral` is similar to an attribute value, but allows the characters\n  `<` and `&` and doesn't replace references.\n\n  @returns {string|false}\n    Value of the `SystemLiteral` minus quotes, or `false` if nothing was\n    consumed. An empty string indicates that a `SystemLiteral` was consumed but\n    was empty.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-SystemLiteral\n  */\n  consumeSystemLiteral() {\n    let { scanner } = this;\n    let quote = scanner.consumeStringFast('\"') || scanner.consumeStringFast(\"'\");\n\n    if (!quote) {\n      return false;\n    }\n\n    let value = scanner.consumeUntilString(quote);\n    this.validateChars(value);\n\n    if (!scanner.consumeStringFast(quote)) {\n      this.error('Missing end quote');\n    }\n\n    return value;\n  }\n\n  /**\n  Consumes one or more whitespace characters if possible.\n\n  @returns {boolean}\n    Whether any whitespace characters were consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#white\n  */\n  consumeWhitespace() {\n    return Boolean(this.scanner.consumeMatchFn(syntax.isWhitespace));\n  }\n\n  /**\n  Consumes an XML declaration if possible.\n\n  @returns {boolean}\n    Whether an XML declaration was consumed.\n\n  @see https://www.w3.org/TR/2008/REC-xml-20081126/#NT-XMLDecl\n  */\n  consumeXmlDeclaration() {\n    let { scanner } = this;\n\n    if (!scanner.consumeStringFast('<?xml')) {\n      return false;\n    }\n\n    if (!this.consumeWhitespace()) {\n      this.error('Invalid XML declaration');\n    }\n\n    let version = Boolean(scanner.consumeStringFast('version'))\n      && this.consumeEqual()\n      && this.consumeSystemLiteral();\n\n    if (version === false) {\n      this.error('XML version is missing or invalid');\n    } else if (!/^1\\.[0-9]+$/.test(version)) {\n      this.error('Invalid character in version number');\n    }\n\n    if (this.consumeWhitespace()) {\n      let encoding = Boolean(scanner.consumeStringFast('encoding'))\n        && this.consumeEqual()\n        && this.consumeSystemLiteral();\n\n      if (encoding) {\n        this.consumeWhitespace();\n      }\n\n      let standalone = Boolean(scanner.consumeStringFast('standalone'))\n        && this.consumeEqual()\n        && this.consumeSystemLiteral();\n\n      if (standalone) {\n        if (standalone !== 'yes' && standalone !== 'no') {\n          this.error('Only \"yes\" and \"no\" are permitted as values of `standalone`');\n        }\n\n        this.consumeWhitespace();\n      }\n    }\n\n    if (!scanner.consumeStringFast('?>')) {\n      this.error('Invalid or unclosed XML declaration');\n    }\n\n    return true;\n  }\n\n  /**\n  Throws an error at the current scanner position.\n\n  @param {string} message\n  */\n  error(message) {\n    let { charIndex, string: xml } = this.scanner;\n    let column = 1;\n    let excerpt = '';\n    let line = 1;\n\n    // Find the line and column where the error occurred.\n    for (let i = 0; i < charIndex; ++i) {\n      let char = xml[i];\n\n      if (char === '\\n') {\n        column = 1;\n        excerpt = '';\n        line += 1;\n      } else {\n        column += 1;\n        excerpt += char;\n      }\n    }\n\n    let eol = xml.indexOf('\\n', charIndex);\n\n    excerpt += eol === -1\n      ? xml.slice(charIndex)\n      : xml.slice(charIndex, eol);\n\n    let excerptStart = 0;\n\n    // Keep the excerpt below 50 chars, but always keep the error position in\n    // view.\n    if (excerpt.length > 50) {\n      if (column < 40) {\n        excerpt = excerpt.slice(0, 50);\n      } else {\n        excerptStart = column - 20;\n        excerpt = excerpt.slice(excerptStart, column + 30);\n      }\n    }\n\n    let err = new Error(\n      `${message} (line ${line}, column ${column})\\n`\n        + `  ${excerpt}\\n`\n        + ' '.repeat(column - excerptStart + 1) + '^\\n'\n    );\n\n    Object.assign(err, {\n      column,\n      excerpt,\n      line,\n      pos: charIndex\n    });\n\n    throw err;\n  }\n\n  /**\n  Throws an invalid character error if any character in the given _string_ isn't\n  a valid XML character.\n\n  @param {string} string\n  */\n  validateChars(string) {\n    let charIndex = 0;\n\n    for (let char of string) {\n      if (syntax.isNotXmlChar(char)) {\n        this.scanner.reset(-([ ...string ].length - charIndex));\n        this.error('Invalid character');\n      }\n\n      charIndex += 1;\n    }\n  }\n}\n\nmodule.exports = Parser;\n\n// -- Private Functions --------------------------------------------------------\n\n/**\nNormalizes the given XML string by stripping a byte order mark (if present) and\nreplacing CRLF sequences and lone CR characters with LF characters.\n\n@param {string} xml\n@returns {string}\n*/\nfunction normalizeXmlString(xml) {\n  if (xml[0] === '\\uFEFF') {\n    xml = xml.slice(1);\n  }\n\n  return xml.replace(/\\r\\n?/g, '\\n');\n}\n\n/** @typedef {import('./XmlNode')} XmlNode */\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}